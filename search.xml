<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Utterance Detection in Amazon</title>
      <link href="/2020/04/22/asr/utterance-detection-in-amazon/"/>
      <url>/2020/04/22/asr/utterance-detection-in-amazon/</url>
      
        <content type="html"><![CDATA[<p>最近粗略的接触了些话音检测和噪声过滤的工作，有参考到Amazon的相关论文，在此分享下论文的主要方法和贡献。本次分享的两篇论文方法套路基本一样，只是分别使用于不同的场景，一篇是用在端点检测（END-OF-UTTERANCE DETECTION）上，用来判断用户是否已经结束语音指令。另一篇是应用在Device-directed Utterance Detection上，应该主要是用在echo音箱等vpa上，用来过滤一些误触发，用户正对着设备下发的指令认为是正例，而背景噪音，细碎的嬉笑打闹聊天的声音认为是负例，不应该触发， 所以叫Device-directed Utterance Detection。</p><a id="more"></a><h2 id="Device-directed-Utterance-Detection"><a href="#Device-directed-Utterance-Detection" class="headerlink" title="Device-directed Utterance Detection"></a>Device-directed Utterance Detection</h2><h3 id="方法及贡献"><a href="#方法及贡献" class="headerlink" title="方法及贡献"></a>方法及贡献</h3><p>模型可简单概括为三种特征+一个分类器，作者用两个LSTM分别对声学和识别结果分别做embedding，再加上decoder输出的一些特征，最后将三个特征结合起来作为最后分类器的输入。系统结构如下右图所示。这种做法还是比较直观的，三部分特征刚好对应语音识别系统三大部件的输出，对 1-best hypotheses的处理基本可以理解为对语言模型的embedding。最后是一个二分类器，判断本次query是否是Device-directed话音。下左图是正负例的一些样例。</p><table><thead><tr><th><!-- --></th><th><!-- --></th></tr></thead><tbody><tr><td><img src="http://img.kingway.fun/IMGMatrix/blog/2020/04/amazon-spd-2.png" alt=""></td><td><img src="http://img.kingway.fun/IMGMatrix/blog/2020/04/amazon-spd-1.png" alt=""></td></tr></tbody></table><h3 id="模型与参数"><a href="#模型与参数" class="headerlink" title="模型与参数"></a>模型与参数</h3><h4 id="Acoustic-Embedding"><a href="#Acoustic-Embedding" class="headerlink" title="Acoustic Embedding"></a>Acoustic Embedding</h4><p>Acoustic Embedding 用LSTM做帧级别的device-directed target的预测，输入是每一帧log filter-bank energies (LFBEs)，以25ms帧长和10ms帧移分帧，每一帧的label都和整条query的label一样，最后使用cross-entropy Loss，SGD训练。做softmax之前的两维向量拿出来，作为Acoustic Embedding。</p><h4 id="ASR-feature"><a href="#ASR-feature" class="headerlink" title="ASR feature"></a>ASR feature</h4><p>ASR的输出特征论文里讲的有18维，但未全部给出，只介绍里其中的三维，其一是帧前向概率的平均值，先计算每一帧的前向概率的熵，所有帧的均值即为所得，熵越大说明前向的概率分布差不多，1-best的confidence就越低。 其二是1-best的viterbi cost。 其三是计算lattice节点出边的平均值。</p><h4 id="Character-Embedding"><a href="#Character-Embedding" class="headerlink" title="Character Embedding"></a>Character Embedding</h4><p>Character Embedding和Acoustic Embedding的思路基本一样，也是使用LSTM。只不过输入是1-best输出character级别的embedding，每个character的embedding <a href="https://github.com/stanfordnlp/GloVe" target="_blank" rel="noopener">GloVE</a>来训练。也是取最后一个character的输出作为这部分的Embedding（2维）。</p><h4 id="Classification-Layer"><a href="#Classification-Layer" class="headerlink" title="Classification Layer"></a>Classification Layer</h4><p>最后一个分类层使用的就是简单的两层前馈神经网络，在另一篇论文里有讲，隐藏层节点为100。</p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>论文的实验数据是在他们自己产品的数据集，并未公开，下面是一些实验结果。</p><ul><li><p>参数选择<br>作者对LSTM的层数和节点数以及character embedding的维数做了对比实验，实验结果如下图。</p><table><thead><tr><th><!-- --></th><th><!-- --></th></tr></thead><tbody><tr><td><img src="http://img.kingway.fun/IMGMatrix/blog/2020/04/amazon-spd-3.png" alt=""></td><td><img src="http://img.kingway.fun/IMGMatrix/blog/2020/04/amazon-spd-4.png" alt=""></td></tr></tbody></table></li><li><p>性能比较<br>作者还对比了三种单独特征及融合特征对分类的影响，实验显示单单ASR decoder 特征效果最好，多特征的话效果更加。模型用Detection error tradeoff (DET)评价，跟ROC曲线差不多的意思，只是横纵轴定义不一样。</p><table><thead><tr><th><!-- --></th><th><!-- --></th></tr></thead><tbody><tr><td><img src="http://img.kingway.fun/IMGMatrix/blog/2020/04/amazon-spd-5.png" alt=""></td><td><img src="http://img.kingway.fun/IMGMatrix/blog/2020/04/amazon-spd-6.png" alt=""></td></tr></tbody></table></li></ul><p>我们参考了此篇论文的思路，目前只使用了ASR Decoder的特征，不过由于decoder实现不一样，采用的特征和维度都不一样，效果也还行，这是可以解释的，ASR Decoder输出的特征是声学模型和语言模型这两个大模型生成的，区分度应该不错。</p><h2 id="End-of-Utterance-detection"><a href="#End-of-Utterance-detection" class="headerlink" title="End-of-Utterance detection"></a>End-of-Utterance detection</h2><p>End-of-Utterance检测也叫enpoint检测，主要是判断用户是否说完话了，对端到端的速度和用户体验至关重要，既不能提前（会打断用户说话），也不能延后（端到端速度慢，体验差）。简单说endpoint检测的目标就是保持准确率高的前提下尽可能快的检测到用户说完话的意图，这当然需要trade-off，一个灵敏的检测器有可能会截断用户的query导致准确率下降。 <a href="https://github.com/kaldi-asr/kaldi" target="_blank" rel="noopener">Kaldi</a>里面的通常做法是计算解码时lattice里面的末尾silence帧的数量，达到一定长度并且满足对应的cost阈值就认为是endpoint，这种方法纯从解码器的角度出发，利用声学模型的输出，没有对声学特征做另外的建模。工业实践上为了效果和计算资源，一般还会在语音识别前面加一个voice-activity-detection (VAD)检测，本文也是这个思路。 这篇论文发表的时间要早于上面那篇，而且要解决的问题也比上篇要复杂。</p><h3 id="方法及贡献-1"><a href="#方法及贡献-1" class="headerlink" title="方法及贡献"></a>方法及贡献</h3><p>本文模型结构基本和上文是一样的（上文借鉴本文）， 特征也是三个部分组成Acoustic Eembedding和 1-best hypotheses Eembedding和ASR输出的feature，最后加个二分类器，不过上文主要论证比较ASR feature的有效性，此本则偏重与Acoustic部分。另外，这篇论文是在远场环境上做的，一般来说远场环境的困难要大得多。</p><table><thead><tr><th><!-- --></th><th><!-- --></th></tr></thead><tbody><tr><td><img src="http://img.kingway.fun/IMGMatrix/blog/2020/04/amazon-epd-2.png" alt=""></td><td><img src="http://img.kingway.fun/IMGMatrix/blog/2020/04/amazon-epd-1.png" alt=""></td></tr></tbody></table><p>不同的地方主要有以下几点：</p><ul><li>Acoustic 部分做的是多任务学习，将声学feature同时用于训练VAD和endpoint检测，而且与上文不同，label是帧级别的，所以训练时需要对齐特征和label，如上右图所示。取VAD部分取输出给Inference时计算阈值，endpoint部分则取pre-softmax的特征作为最后二分类器的输入。</li><li>1-best hypotheses embedding部分使用的是word embedding，由于输出和帧无法一一对应，如果ASR输出的partial没有变化，则会一直延用最新的word embedding。</li><li>ASR feature 方面只介绍了个pause duration，这个应该跟kaidi检测endpoint类似，计算lattice（或其他类似解码网格）的末尾静音帧数。</li></ul><h3 id="Inference-Pipeline"><a href="#Inference-Pipeline" class="headerlink" title="Inference Pipeline"></a>Inference Pipeline</h3><p>上面介绍Acoustic部分分为两部分vad + endpoint，在inference是先用vad的输出判断静音的持续时间，通过阈值Tmin，Tmax来判断是否启用endpoint检测（二分类器的输出）。在下面两种情况下认为检测到endpoint，当vad给出的静音阈值大于Tmin并且最终二分类器输出为endpoint，或者vad给出的静音阈值超过Tmax。 endpoint检测是一个比较困难的题目，实际工业应用基本不可能单模型就解决得很好，一般都使用多模型融合。</p><h3 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h3><ul><li><p>特征性能比较<br>实验部分照例比较了三种特征的性能和融合后的性能，Acoustic 单特征最后，融合能带来性能的提升。</p><table><thead><tr><th><!-- --></th><th><!-- --></th></tr></thead><tbody><tr><td><img src="http://img.kingway.fun/IMGMatrix/blog/2020/04/amazon-epd-3.png" alt=""></td><td><img src="http://img.kingway.fun/IMGMatrix/blog/2020/04/amazon-epd-4.png" alt=""></td></tr></tbody></table></li><li><p>混合语言的效果<br>作者还进行了混合语言的效果，说明本模型跟语言并不太相关，即模型架构不需要改变，换批训练数据，在其他语言上也能达到相同的效果。这当然是最理想的结果，相关实验结果如下。</p></li></ul><table><thead><tr><th><!-- --></th></tr></thead><tbody><tr><td><img src="http://img.kingway.fun/IMGMatrix/blog/2020/04/amazon-epd-5.png" alt=""></td></tr></tbody></table><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>[1] <a href="https://docs.qq.com/pdf/DRUtsWlVCZ2lFZERU" target="_blank" rel="noopener">Device-directed Utterance Detection</a></li><li>[2] <a href="">COMBINING ACOUSTIC EMBEDDINGSAND DECODING FEATURES FOR END-OF-UTTERANCE DETECTION IN REAL-TIME FAR-FIELD SPEECH RECOGNITION SYSTEMS</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Speech Recognition </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASR </tag>
            
            <tag> 论文 </tag>
            
            <tag> amazon </tag>
            
            <tag> Utterance Detection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习人类语言处理 公开课</title>
      <link href="/2020/03/28/asr/lihongyi-nlp/"/>
      <url>/2020/03/28/asr/lihongyi-nlp/</url>
      
        <content type="html"><![CDATA[<p>李宏毅《深度学习人类语言处理》公开课<br>课程地址：<a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_DLHLP20.html" target="_blank" rel="noopener">http://speech.ee.ntu.edu.tw/~tlkagk/courses_DLHLP20.html</a>  </p><a id="more"></a><h3 id="P1-Course-Overview"><a href="#P1-Course-Overview" class="headerlink" title="P1 : Course Overview"></a>P1 : Course Overview</h3><iframe style="width: 100%; height: 500px" src="//player.bilibili.com/player.html?aid=94310884&bvid=BV1QE411p7z3&cid=161006931&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="P2-Speech-Recognition-Part-1"><a href="#P2-Speech-Recognition-Part-1" class="headerlink" title="P2 : Speech Recognition (Part 1)"></a>P2 : Speech Recognition (Part 1)</h3><iframe style="width: 100%; height: 500px" src="//player.bilibili.com/player.html?aid=94310884&bvid=BV1QE411p7z3&cid=161006956&page=2" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="P3-Listen-Attend-Spell-part-2"><a href="#P3-Listen-Attend-Spell-part-2" class="headerlink" title="P3 : Listen, Attend, Spell (part 2)"></a>P3 : Listen, Attend, Spell (part 2)</h3><iframe style="width: 100%; height: 500px" src="//player.bilibili.com/player.html?aid=94310884&bvid=BV1QE411p7z3&cid=163087865&page=3" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="P4-CTC-RNN-T-and-more-part-3"><a href="#P4-CTC-RNN-T-and-more-part-3" class="headerlink" title="P4 : CTC, RNN-T and more (part 3)"></a>P4 : CTC, RNN-T and more (part 3)</h3><iframe style="width: 100%; height: 500px" src="//player.bilibili.com/player.html?aid=94310884&bvid=BV1QE411p7z3&cid=163087693&page=4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="P5-HMM"><a href="#P5-HMM" class="headerlink" title="P5 : HMM"></a>P5 : HMM</h3><iframe style="width: 100%; height: 500px" src="//player.bilibili.com/player.html?aid=94310884&bvid=BV1QE411p7z3&cid=166218711&page=5" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="P6-Alignment-of-HMM-CTC-and-RNN-T"><a href="#P6-Alignment-of-HMM-CTC-and-RNN-T" class="headerlink" title="P6 : Alignment of HMM, CTC and RNN-T"></a>P6 : Alignment of HMM, CTC and RNN-T</h3><iframe style="width: 100%; height: 500px" src="//player.bilibili.com/player.html?aid=94310884&bvid=BV1QE411p7z3&cid=166222248&page=6" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="P7-RNN-T-Training"><a href="#P7-RNN-T-Training" class="headerlink" title="P7 : RNN-T Training"></a>P7 : RNN-T Training</h3><iframe style="width: 100%; height: 500px" src="//player.bilibili.com/player.html?aid=94310884&bvid=BV1QE411p7z3&cid=167357962&page=7" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="P8-Language-Modeling"><a href="#P8-Language-Modeling" class="headerlink" title="P8 : Language Modeling"></a>P8 : Language Modeling</h3><iframe style="width: 100%; height: 500px" src="//player.bilibili.com/player.html?aid=94310884&bvid=BV1QE411p7z3&cid=169402582&page=8" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="P9-Voice-Conversion"><a href="#P9-Voice-Conversion" class="headerlink" title="P9 : Voice Conversion"></a>P9 : Voice Conversion</h3><iframe style="width: 100%; height: 500px" src="//player.bilibili.com/player.html?aid=94310884&bvid=BV1QE411p7z3&cid=169681445&page=9" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
      
      
      <categories>
          
          <category> Speech Recognition </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 公开课 </tag>
            
            <tag> NLP </tag>
            
            <tag> ASR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Towords End-to-End Speech Recognition</title>
      <link href="/2020/02/26/asr/towords-e2e-asr/"/>
      <url>/2020/02/26/asr/towords-e2e-asr/</url>
      
        <content type="html"><![CDATA[<p>Google’s End-to-End Speech Recognition Tutorial at ISCSLP 2018 </p><a id="more"></a><p><embed style="width: 100%; height: 800px" src="https://docs.qq.com/pdf/DRWdnd1VvQnlmQ0RE" frameborder=0 allowfullscreen></embed></p>]]></content>
      
      
      <categories>
          
          <category> Speech Recognition </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASR </tag>
            
            <tag> 论文 </tag>
            
            <tag> tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++仿函数</title>
      <link href="/2019/08/17/cpp/c-functor/"/>
      <url>/2019/08/17/cpp/c-functor/</url>
      
        <content type="html"><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>functor的英文解释为something that performs a function，即其行为类似函数的东西。C++中的仿函数是通过在类中重载()运算符实现，使你可以像使用函数一样来创建类的对象。  </p><a id="more"></a><h4 id="C中是怎么实现这个功能的"><a href="#C中是怎么实现这个功能的" class="headerlink" title="C中是怎么实现这个功能的"></a>C中是怎么实现这个功能的</h4><p>使用指针函数和回调函数，比如qsort的比较函数</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">sort_function</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token operator">-</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">int</span> list<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">54</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">67</span><span class="token punctuation">,</span> <span class="token number">22</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token function">qsort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>list<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sort_function<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//起始地址，个数，元素大小，回调函数 </span>   <span class="token keyword">int</span>  x<span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span>       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%i\n"</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="C-中的仿函数"><a href="#C-中的仿函数" class="headerlink" title="C++ 中的仿函数"></a>C++ 中的仿函数</h4><ul><li>一个例子(增加任意常数)<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// this is a functor</span><span class="token keyword">struct</span> add_x <span class="token punctuation">{</span><span class="token function">add_x</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>private<span class="token punctuation">:</span><span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// usage:</span>add_x <span class="token function">add42</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// create an instance of the functor class</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">add42</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// and "call" it</span><span class="token function">assert</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// and it added 42 to its argument</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">in</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">out</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> in<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  in<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Pass a functor to std::transform, which calls the functor on every element </span><span class="token comment" spellcheck="true">// in the input sequence, and stores the result to the output sequence</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">transform</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> in<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> out<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">add_x</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> in<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">assert</span><span class="token punctuation">(</span>out<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> in<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>迭代和计算逻辑分开（for_each 求和例子）<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> sum <span class="token punctuation">{</span>  <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> t<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token function">total</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">int</span><span class="token operator">*</span> total<span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token operator">*</span>total <span class="token operator">+</span><span class="token operator">=</span> element<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  sum <span class="token function">s</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>total<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">for_each</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> arr <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> total <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// prints total = 15;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>for_each 为STL的非变易算法，是一组不破坏操作数据的模板函数，对[first,last)数据逐个处理，执行由单参数函数对象所定义的操作。</p></blockquote></li><li>仿函数可以是有状态的，可以应用到多个集合中。<br>一个例子（对多个数据集取平均）<pre class="line-numbers language-c"><code class="language-c">class CalculateAverage <span class="token punctuation">{</span>public<span class="token punctuation">:</span>  <span class="token function">CalculateAverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">acc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">n</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">float</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> acc <span class="token operator">+</span><span class="token operator">=</span> x<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token keyword">float</span> <span class="token function">getAverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> acc <span class="token operator">/</span> n<span class="token punctuation">;</span> <span class="token punctuation">}</span>private<span class="token punctuation">:</span>  <span class="token keyword">float</span> acc<span class="token punctuation">;</span>  <span class="token keyword">int</span>   n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>CalculateAverage avg<span class="token punctuation">;</span>avg <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">for_each</span><span class="token punctuation">(</span>dataA<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dataA<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> avg<span class="token punctuation">)</span><span class="token punctuation">;</span>avg <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">for_each</span><span class="token punctuation">(</span>dataB<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dataB<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> avg<span class="token punctuation">)</span><span class="token punctuation">;</span>avg <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">for_each</span><span class="token punctuation">(</span>dataC<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dataC<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> avg<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> avg<span class="token punctuation">.</span><span class="token function">getAverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>仿函数的性能<br>使用仿函数编译器可以准确知道需要调用哪个函数。这意味着它可以内联这个函数调用。而如果使用函数指针，编译器不能直接确定指针指向的函数，而这必须在程序运行时才能得到并调用。一个例子就是比较std::sort 和qsort ，STL的版本一般要快5-10倍。</li><li>STL 内建仿函数<pre class="line-numbers language-c"><code class="language-c">plus<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token comment" spellcheck="true">// plus example</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>     </span><span class="token comment" spellcheck="true">// std::cout</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;functional></span>   </span><span class="token comment" spellcheck="true">// std::plus</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span>    </span><span class="token comment" spellcheck="true">// std::transform</span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> first<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> second<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> results<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">transform</span> <span class="token punctuation">(</span>first<span class="token punctuation">,</span> first<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">,</span> second<span class="token punctuation">,</span> results<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>plus<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> results<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出</span><span class="token comment" spellcheck="true">// 11 22 33 44 55</span>minus<span class="token operator">&lt;</span>T<span class="token operator">></span>multiplies<span class="token operator">&lt;</span>T<span class="token operator">></span>divides<span class="token operator">&lt;</span>T<span class="token operator">></span>modulus<span class="token operator">&lt;</span>T<span class="token operator">></span>negate<span class="token operator">&lt;</span>T<span class="token operator">></span>equal_to<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token comment" spellcheck="true">// equal_to example</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>     </span><span class="token comment" spellcheck="true">// std::cout</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;utility></span>      </span><span class="token comment" spellcheck="true">// std::pair</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;functional></span>   </span><span class="token comment" spellcheck="true">// std::equal_to</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span>    </span><span class="token comment" spellcheck="true">// std::mismatch</span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span> ptiter<span class="token punctuation">;</span><span class="token keyword">int</span> foo<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> bar<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">,</span><span class="token number">160</span><span class="token punctuation">}</span><span class="token punctuation">;</span>ptiter <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">mismatch</span> <span class="token punctuation">(</span>foo<span class="token punctuation">,</span> foo<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">,</span> bar<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>equal_to<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"First mismatching pair is: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ptiter<span class="token punctuation">.</span>first<span class="token punctuation">;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">" and "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ptiter<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出</span><span class="token comment" spellcheck="true">// First mismatching pair is: 30 and 40</span>not_equal_to<span class="token operator">&lt;</span>T<span class="token operator">></span>greater<span class="token operator">&lt;</span>T<span class="token operator">></span>greater_equal<span class="token operator">&lt;</span>T<span class="token operator">></span>less<span class="token operator">&lt;</span>T<span class="token operator">></span>less_equal<span class="token operator">&lt;</span>T<span class="token operator">></span>logical_and<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token comment" spellcheck="true">// logical_and example</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>     </span><span class="token comment" spellcheck="true">// std::cout, std::boolalpha</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;functional></span>   </span><span class="token comment" spellcheck="true">// std::logical_and</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span>    </span><span class="token comment" spellcheck="true">// std::transform</span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>bool foo<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>true<span class="token punctuation">,</span>false<span class="token punctuation">,</span>true<span class="token punctuation">,</span>false<span class="token punctuation">}</span><span class="token punctuation">;</span>bool bar<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>true<span class="token punctuation">,</span>true<span class="token punctuation">,</span>false<span class="token punctuation">,</span>false<span class="token punctuation">}</span><span class="token punctuation">;</span>bool result<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">transform</span> <span class="token punctuation">(</span>foo<span class="token punctuation">,</span> foo<span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">,</span> bar<span class="token punctuation">,</span> result<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>logical_and<span class="token operator">&lt;</span>bool<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>boolalpha <span class="token operator">&lt;&lt;</span> <span class="token string">"Logical AND:\n"</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> foo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" AND "</span> <span class="token operator">&lt;&lt;</span> bar<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" = "</span> <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出</span><span class="token comment" spellcheck="true">// Logical AND:</span><span class="token comment" spellcheck="true">// true AND true = true</span><span class="token comment" spellcheck="true">// false AND true = false</span><span class="token comment" spellcheck="true">// true AND false = false</span><span class="token comment" spellcheck="true">// false AND false = false</span>logical_or<span class="token operator">&lt;</span>T<span class="token operator">></span>logical_no<span class="token operator">&lt;</span>T<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++使用LD_PRELOAD劫持（Hook）库函数</title>
      <link href="/2019/06/13/cpp/c-hook/"/>
      <url>/2019/06/13/cpp/c-hook/</url>
      
        <content type="html"><![CDATA[<p>在调试C++程序的时候，我们并不是每次都能拿到源代码，很多时候我们只能得到一个动态库so，调试时这个动态库就是一个黑匣子，没办法查看修改或者在里面加日志，那么我们是不是就没有任何办法对我们感兴趣的函数和参数进行监控和跟踪了呢？  </p><a id="more"></a><p>对于这种情况，我们一般会挂上<code>gdb</code>,然后在我们感兴趣的地方打上断点，然后查看堆栈里的变量的值。但这个过程时比较繁琐的，尤其是在需要了解程序执行的大量中间过程时是非常让人抓狂的。下面我们将介绍一种使用钩子函数的方法，来修改目标函数的运行时的行为，来达到我们跟踪函数运行的目的。  </p><p>钩子函数可以在运行时劫持预先存在的函数，我们可以在钩子函数里对预先的函数做一些包装，使得函数保持原来的功能的前提下做一些额外的操作。在本文中我们主要的是linux系统的动态加载API，动态加载允许在运行时加载并运行动态链接库里的函数，所以我们可以把钩子函数打包成动态链接库，以实现对现有函数的劫持。实现这个功能需要用到LD_PRELOAD环境变量，使用LD_PRELOAD加载的动态库会最先被加载，这就使得我们有机会可以在钩子函数里运用动态加载技术将原先的函数绑定到钩子函数中，从而达到监控及跟踪的效果。</p><p>下面就以最简单的hello world的例子来讲解这一切是怎么做到的。<br>首先main函数，helloworld.c</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Hello world!n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再是钩子函数，example.c</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;dlfcn.h></span></span><span class="token keyword">int</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>message<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>new_puts<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> result<span class="token punctuation">;</span>  new_puts <span class="token operator">=</span> <span class="token function">dlsym</span><span class="token punctuation">(</span>RTLD_NEXT<span class="token punctuation">,</span> <span class="token string">"puts"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> <span class="token string">"Hello world!n"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    result <span class="token operator">=</span> <span class="token function">new_puts</span><span class="token punctuation">(</span><span class="token string">"Goodbye, cruel world!n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    result <span class="token operator">=</span> <span class="token function">new_puts</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个样例里，我们劫持了标准库里的<code>puts</code>函数。简单看一下代码。<br>第四行我们定义了一个和标准库里有一模一样签名的<code>puts</code>函数，这是能劫持<code>puts</code>函数的关键，钩子函数的签名一定要和原函数一模一样。<br>第五行我们又声明了一个和原函数参数一样的函数指针，这个指针用来后面指向原函数。<br>第九行利用<code>dlsym</code>函数获取原函数的指针并赋给上面声明的指针，<code>RTLD_NEXT</code>这个枚举变量告诉动态加载器加载第二个参数（在本例中为<code>puts</code>）相关联的函数的下一个实例也就是原函数里的<code>puts</code>。<br>后面的<code>if</code>判断里我们比较传进来的参数，然后输出不同的结果，从而在运行时改变程序的行为。</p><p>编译运行看一下</p><pre class="line-numbers language-bash"><code class="language-bash">kingway@ubuntu:~/code$ gcc helloworld.c -o helloworldkingway@ubuntu:~/code$ gcc example.c -o libexample.so -fPIC -shared -ldl -D_GNU_SOURCE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>helloworld.c正常编译成可执行文件就行，example.c我们需要编译成位置无关的动态链接库，<code>-ldl -D_GNU_SOURCE</code>是必须的，这样我们才能使用动态加载API，并且访问<code>RTLD_NEXT</code>枚举变量。</p><p>看一下运行的结果</p><pre class="line-numbers language-bash"><code class="language-bash">kingway@ubuntu:~/code$ <span class="token function">export</span> LD_PRELOAD<span class="token operator">=</span><span class="token string">"/home/kingway/code/libexample.so"</span>kingway@ubuntu:~/code$ ./helloworldGoodbye, cruel world<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到Hello world成功被劫持，并输出了钩子函数里的结果。这只是一个简单的例子，但通过这种方法，我们可以轻松的劫持黑匣子动态链接库的函数，并在必要时进行一些修改，达到调试的目的。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11智能指针</title>
      <link href="/2019/06/03/cpp/cpp-smart-pointer/"/>
      <url>/2019/06/03/cpp/cpp-smart-pointer/</url>
      
        <content type="html"><![CDATA[<p>很多人怕写C/C++ 程序就是因为指针，因为指针给了程序员高度的自由，同样也赋予了高度的责任，稍有不慎就导致内存泄漏。其实写C++ 可以完全不用指针，尤其C++ 11对智能指针作了进一步的升级，在不需要使用任何裸指针的前提下也可以写出高效的C++ 程序。C++ 11中定义了<code>unique_ptr</code>、<code>shared_ptr</code>与<code>weak_ptr</code>三种智能指针(smart pointer)，都包含在<code>&lt;memory&gt;</code>头文件中。智能指针可以对动态分配的资源进行管理，保证任何情况下，已构造的对象最终会销毁，即它的析构函数最终会被调用。</p><a id="more"></a><h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p>如名字所示，<code>unique_ptr</code>是个独占指针，C++ 11之前就已经存在，<code>unique_ptr</code>所指的内存为自己独有，某个时刻只能有一个<code>unique_ptr</code>指向一个给定的对象，不支持拷贝和赋值。下面以代码样例来说明<code>unique_ptr</code>的用法，各种情况都在代码注释给出。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">up1</span><span class="token punctuation">(</span>new <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 无法复制的unique_ptr</span>    <span class="token comment" spellcheck="true">// unique_ptr&lt;int> up2 = up1;        // err, 不能通过编译</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>up1 <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 11</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> up3 <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">move</span><span class="token punctuation">(</span>up1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 现在p3是数据的唯一的unique_ptr</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>up3 <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 11</span>    <span class="token comment" spellcheck="true">// std::cout &lt;&lt; *up1 &lt;&lt; std::endl;   // err, 运行时错误，空指针</span>    up3<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 显式释放内存</span>    up1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 不会导致运行时错误</span>    <span class="token comment" spellcheck="true">// std::cout &lt;&lt; *up3 &lt;&lt; std::endl;   // err, 运行时错误，空指针</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">up4</span><span class="token punctuation">(</span>new <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 无法复制的unique_ptr</span>    up4<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>new <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">44</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// "绑定"动态对象</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>up4 <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 44</span>    up4 <span class="token operator">=</span> nullptr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 显式销毁所指对象，同时智能指针变为空指针。与up4.reset()等价</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">up5</span><span class="token punctuation">(</span>new <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">55</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> up5<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 只是释放控制权，不会释放内存</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// cout &lt;&lt; *up5 &lt;&lt; endl; // err, 运行时错误，不再拥有内存</span>    delete p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 释放堆区资源</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p><code>shared_ptr</code>允许多个该智能指针共享“拥有”同一堆分配对象的内存，这通过引用计数（reference counting）实现，会记录有多少个shared_ptr共同指向一个对象，一旦最后一个这样的指针被销毁，也就是一旦某个对象的引用计数变为0，这个对象会被自动删除。支持复制和赋值操作。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp1</span><span class="token punctuation">(</span>new <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> sp2 <span class="token operator">=</span> sp1<span class="token punctuation">;</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"cout: "</span> <span class="token operator">&lt;&lt;</span> sp2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 打印引用计数, 2</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp1 <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 22</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp2 <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 22</span>    sp1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 显示让引用计数减一</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"count: "</span> <span class="token operator">&lt;&lt;</span> sp2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 打印引用计数, 1</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp2 <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 22</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了上面出现的<code>use_count</code>和<code>reset</code>之外，还有<code>unique</code>返回是否是独占所有权(use_count 为 1)，<code>swap</code>交换两个shared_ptr对象(即交换所拥有的对象)，<code>get</code>返回内部对象(指针)几个成员函数。</p><ul><li>make_shared 函数<br>最安全的分配和使用动态内存的方法是调用一个名为<code>make_shared</code>的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的<code>shared_ptr</code>。当要用<code>make_shared</code>时，必须指定想要创建的对象的类型或者使用更为简洁的<code>auto</code>，如下：<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 指向一个值为42的int的shared_ptr</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p3 <span class="token operator">=</span> make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// p4指向一个值为"9999999999"的string</span>shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> p4 <span class="token operator">=</span> make_shared<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// p5指向一个值初始化的int,值为0</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p5 <span class="token operator">=</span> make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// p6指向一个动态分配的空vector&lt;string></span><span class="token keyword">auto</span> p6 <span class="token operator">=</span> make_shared<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>当进行拷贝或赋值操作时，每个<code>shared_ptr</code>都会记录有多少个其他<code>shared_ptr</code>指向相同的对象：<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">auto</span> p <span class="token operator">=</span> make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//p指向的对象只有p一个引用者</span><span class="token keyword">auto</span> <span class="token function">q</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">//p和q指向相同对象，此对象有两个引用者    </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><p><code>weak_ptr</code>是为配合<code>shared_ptr</code>而引入的一种智能指针来协助<code>shared_ptr</code>工作，它可以从一个shared_ptr或另一个weak_ptr对象构造，它的构造和析构不会引起引用计数的增加或减少。没有重载 <code>*</code>和 <code>-&gt;</code> 但可以使用lock获得一个可用的<code>shared_ptr</code>对象</p><p><code>weak_ptr</code>的使用更为复杂一点，它可以指向<code>shared_ptr</code>指针指向的对象内存，却并不拥有该内存，而使用<code>weak_ptr</code>成员<code>lock</code>，则可返回其指向内存的一个<code>share_ptr</code>对象，且在所指对象内存已经无效时，返回指针空值nullptr。</p><p><strong>注意：weak_ptr并不拥有资源的所有权，所以不能直接使用资源。</strong> 可以从一个<code>weak_ptr</code>构造一个<code>shared_ptr</code>以取得共享资源的所有权。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span><span class="token keyword">void</span> <span class="token function">check</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>wp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> sp <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 转换为shared_ptr&lt;int></span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sp <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"still: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"still: "</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"pointer is invalid"</span> <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp1</span><span class="token punctuation">(</span>new <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> sp2 <span class="token operator">=</span> sp1<span class="token punctuation">;</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp <span class="token operator">=</span> sp1<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 指向shared_ptr&lt;int>所指对象</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"count: "</span> <span class="token operator">&lt;&lt;</span> wp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// count: 2</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp1 <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 22</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp2 <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 22</span>    <span class="token function">check</span><span class="token punctuation">(</span>wp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// still: 22</span>    sp1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"count: "</span> <span class="token operator">&lt;&lt;</span> wp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// count: 1</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp2 <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 22</span>    <span class="token function">check</span><span class="token punctuation">(</span>wp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// still: 22</span>    sp2<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"count: "</span> <span class="token operator">&lt;&lt;</span> wp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// count: 0</span>    <span class="token function">check</span><span class="token punctuation">(</span>wp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// still: pointer is invalid</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>为什么要使用weak_ptr  </p></li><li><p><em>weak_ptr解决shared_ptr循环引用的问题*</em><br>定义两个类，每个类中又包含一个指向对方类型的智能指针作为成员变量，然后创建对象，设置完成后查看引用计数后退出，看一下测试结果：</p><pre class="line-numbers language-c"><code class="language-c">class CB<span class="token punctuation">;</span>class CA<span class="token punctuation">{</span>public<span class="token punctuation">:</span>   <span class="token function">CA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CA() called! "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>   <span class="token operator">~</span><span class="token function">CA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~CA() called! "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>   <span class="token keyword">void</span> <span class="token function">set_ptr</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>CB<span class="token operator">></span><span class="token operator">&amp;</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span> m_ptr_b <span class="token operator">=</span> ptr<span class="token punctuation">;</span> <span class="token punctuation">}</span>   <span class="token keyword">void</span> <span class="token function">b_use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b use count : "</span> <span class="token operator">&lt;&lt;</span> m_ptr_b<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>   <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"this is class CA!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>private<span class="token punctuation">:</span>   shared_ptr<span class="token operator">&lt;</span>CB<span class="token operator">></span> m_ptr_b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>class CB<span class="token punctuation">{</span>public<span class="token punctuation">:</span>   <span class="token function">CB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CB() called! "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>   <span class="token operator">~</span><span class="token function">CB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~CB() called! "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>   <span class="token keyword">void</span> <span class="token function">set_ptr</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>CA<span class="token operator">></span><span class="token operator">&amp;</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span> m_ptr_a <span class="token operator">=</span> ptr<span class="token punctuation">;</span> <span class="token punctuation">}</span>   <span class="token keyword">void</span> <span class="token function">a_use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a use count : "</span> <span class="token operator">&lt;&lt;</span> m_ptr_a<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>   <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"this is class CB!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>private<span class="token punctuation">:</span>   shared_ptr<span class="token operator">&lt;</span>CA<span class="token operator">></span> m_ptr_a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test_refer_to_each_other</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   shared_ptr<span class="token operator">&lt;</span>CA<span class="token operator">></span> <span class="token function">ptr_a</span><span class="token punctuation">(</span>new <span class="token function">CA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   shared_ptr<span class="token operator">&lt;</span>CB<span class="token operator">></span> <span class="token function">ptr_b</span><span class="token punctuation">(</span>new <span class="token function">CB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a use count : "</span> <span class="token operator">&lt;&lt;</span> ptr_a<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>   cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b use count : "</span> <span class="token operator">&lt;&lt;</span> ptr_b<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>   ptr_a<span class="token operator">-></span><span class="token function">set_ptr</span><span class="token punctuation">(</span>ptr_b<span class="token punctuation">)</span><span class="token punctuation">;</span>   ptr_b<span class="token operator">-></span><span class="token function">set_ptr</span><span class="token punctuation">(</span>ptr_a<span class="token punctuation">)</span><span class="token punctuation">;</span>   cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a use count : "</span> <span class="token operator">&lt;&lt;</span> ptr_a<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>   cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b use count : "</span> <span class="token operator">&lt;&lt;</span> ptr_b<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 测试结果</span><span class="token comment" spellcheck="true">// CA() called!</span><span class="token comment" spellcheck="true">// CB() called!</span><span class="token comment" spellcheck="true">// a use count : 1</span><span class="token comment" spellcheck="true">// b use count : 1</span><span class="token comment" spellcheck="true">// a use count : 2</span><span class="token comment" spellcheck="true">// b use count : 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>通过结果可以看到，最后CA和CB的对象并没有被析构，其中的引用效果如下图所示，起初定义完ptr_a和ptr_b时，只有①③两条引用，然后调用函数set_ptr后又增加了②④两条引用，当test_refer_to_each_other这个函数返回时，对象ptr_a和ptr_b被销毁，也就是①③两条引用会被断开，但是②④两条引用依然存在，每一个的引用计数都不为0，结果就导致其指向的内部对象无法析构，造成内存泄漏。<br><img src="http://img.kingway.fun/IMGMatrix/blog/cpp/c11001.png" alt=""></p><p>解决这种状况的办法就是将两个类中的一个成员变量改为weak_ptr对象，因为weak_ptr不会增加引用计数，使得引用形不成环，最后就可以正常的释放内部的对象，不会造成内存泄漏，比如将CB中的成员变量改为weak_ptr对象，代码如下：</p><pre class="line-numbers language-c"><code class="language-c">class CB<span class="token punctuation">{</span>public<span class="token punctuation">:</span>    <span class="token function">CB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CB() called! "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">CB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~CB() called! "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">set_ptr</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>CA<span class="token operator">></span><span class="token operator">&amp;</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span> m_ptr_a <span class="token operator">=</span> ptr<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">a_use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a use count : "</span> <span class="token operator">&lt;&lt;</span> m_ptr_a<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"this is class CB!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>private<span class="token punctuation">:</span>    weak_ptr<span class="token operator">&lt;</span>CA<span class="token operator">></span> m_ptr_a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 测试结果</span><span class="token comment" spellcheck="true">// CA() called!</span><span class="token comment" spellcheck="true">// CB() called!</span><span class="token comment" spellcheck="true">// a use count : 1</span><span class="token comment" spellcheck="true">// b use count : 1</span><span class="token comment" spellcheck="true">// a use count : 1</span><span class="token comment" spellcheck="true">// b use count : 2</span><span class="token comment" spellcheck="true">// ~CA() called!</span><span class="token comment" spellcheck="true">// ~CB() called!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过这次结果可以看到，CA和CB的对象都被正常的析构了，引用关系如下图所示，流程与上一例子相似，但是不同的是④这条引用是通过weak_ptr建立的，并不会增加引用计数，也就是说CA的对象只有一个引用计数，而CB的对象只有2个引用计数，当test_refer_to_each_other这个函数返回时，对象ptr_a和ptr_b被销毁，也就是①③两条引用会被断开，此时CA对象的引用计数会减为0，对象被销毁，其内部的m_ptr_b成员变量也会被析构，导致CB对象的引用计数会减为0，对象被销毁，进而解决了引用成环的问题。</p><p><img src="http://img.kingway.fun/IMGMatrix/blog/cpp/c11002.png" alt=""></p><ul><li><p><strong>weak_ptr 注意事项</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 编译错误 </span><span class="token comment" spellcheck="true">// error C2665: “std::weak_ptr&lt;CA>::weak_ptr”: 3 个重载中没有一个可以转换所有参数类型</span><span class="token comment" spellcheck="true">// weak_ptr&lt;CA> ptr_1(new CA());</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 编译错误</span><span class="token comment" spellcheck="true">// error C2440 : “初始化”: 无法从“std::weak_ptr&lt;CA>”转换为“std::shared_ptr&lt;CA>”</span><span class="token comment" spellcheck="true">// shared_ptr&lt;CA> ptr_3 = wk_ptr;</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 编译错误</span><span class="token comment" spellcheck="true">// 编译必须作用于相同的指针类型之间</span><span class="token comment" spellcheck="true">// wk_ptr_a.swap(wk_ptr_b);         // 调用交换函数</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 编译错误</span><span class="token comment" spellcheck="true">// 编译必须作用于相同的指针类型之间</span><span class="token comment" spellcheck="true">// wk_ptr_b = wk_ptr_a;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>weak_ptr中只有函数lock和expired两个函数比较重要，因为它本身不会增加引用计数，所以它指向的对象可能在它用的时候已经被释放了，所以在用之前需要使用expired函数来检测是否过期，然后使用lock函数来获取其对应的shared_ptr对象，然后进行后续操作：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  shared_ptr<span class="token operator">&lt;</span>CA<span class="token operator">></span> <span class="token function">ptr_a</span><span class="token punctuation">(</span>new <span class="token function">CA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 输出：CA() called!</span>  shared_ptr<span class="token operator">&lt;</span>CB<span class="token operator">></span> <span class="token function">ptr_b</span><span class="token punctuation">(</span>new <span class="token function">CB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 输出：CB() called!</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr_a use count : "</span> <span class="token operator">&lt;&lt;</span> ptr_a<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：ptr_a use count : 1</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr_b use count : "</span> <span class="token operator">&lt;&lt;</span> ptr_b<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：ptr_b use count : 1</span>  weak_ptr<span class="token operator">&lt;</span>CA<span class="token operator">></span> wk_ptr_a <span class="token operator">=</span> ptr_a<span class="token punctuation">;</span>  weak_ptr<span class="token operator">&lt;</span>CB<span class="token operator">></span> wk_ptr_b <span class="token operator">=</span> ptr_b<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>wk_ptr_a<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      wk_ptr_a<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 输出：this is class CA!</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>wk_ptr_b<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      wk_ptr_b<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 输出：this is class CB!</span>  <span class="token punctuation">}</span>  wk_ptr_b<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 将wk_ptr_b的指向清空</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>wk_ptr_b<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      cout <span class="token operator">&lt;&lt;</span> <span class="token string">"wk_ptr_b is invalid"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 输出：wk_ptr_b is invalid 说明改指针已经无效</span>  <span class="token punctuation">}</span>  wk_ptr_b <span class="token operator">=</span> ptr_b<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>wk_ptr_b<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      wk_ptr_b<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 输出：this is class CB! 调用赋值操作后，wk_ptr_b恢复有效</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 最后输出的引用计数还是1，说明之前使用weak_ptr类型赋值，不会影响引用计数</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr_a use count : "</span> <span class="token operator">&lt;&lt;</span> ptr_a<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：ptr_a use count : 1</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr_b use count : "</span> <span class="token operator">&lt;&lt;</span> ptr_b<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：ptr_b use count : 1</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>OK，三个智能指针，鼓捣明白了吗？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux上如何查看物理CPU个数,核数,线程数</title>
      <link href="/2019/04/20/linux/linux-cpu-cores/"/>
      <url>/2019/04/20/linux/linux-cpu-cores/</url>
      
        <content type="html"><![CDATA[<p>现在的处理器一般都会使用超线程技术来实现并行，超线程技术就是利用特殊的硬件指令，把两个逻辑内核模拟成两个物理芯片，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了CPU的闲置时间，提高的CPU的运行效率。</p><a id="more"></a><p>接下来看看物理CPU个数，核数以及线程数的关系</p><p>总核数 = 物理CPU个数 * 每颗物理CPU的核数<br>总逻辑CPU数 = 物理CPU个数 * 每颗物理CPU的核数 * 超线程数</p><p>上述公式中，逻辑CPU数即线程数，即我们常说的4核8线程，32核64线程的线程。</p><ul><li><p>如何查看CPU物理个数</p><pre><code># grep &#39;physical id&#39; /proc/cpuinfo | sort -uphysical id    : 0physical id    : 1</code></pre></li><li><p>如何查看每个物理CPU的核数</p><pre><code># grep &#39;core id&#39; /proc/cpuinfo | sort -u | wc -l8</code></pre></li><li><p>如何查看总的逻辑CPU个数</p><pre><code># grep &#39;processor&#39; /proc/cpuinfo | sort -u | wc -l32</code></pre><p>这个服务器有32个逻辑核，8个物理核，可见该CPU支持并已打开超线程，每个物理核支持两个并行线程。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx反向代理location路径设置</title>
      <link href="/2019/04/19/linux/nginx-location-setting/"/>
      <url>/2019/04/19/linux/nginx-location-setting/</url>
      
        <content type="html"><![CDATA[<p>nginx反向代理路径的配置规则，路径最后有<code>/</code>和没<code>/</code>的区别。</p><a id="more"></a><h4 id="一-location匹配路径末尾没有"><a href="#一-location匹配路径末尾没有" class="headerlink" title="一. location匹配路径末尾没有 /"></a>一. location匹配路径末尾没有 /</h4><p>此时proxy_pass后面的路径必须和location设置的路径一致：</p><pre><code>location /index{   proxy_redirect off;   proxy_set_header        Host $host;   proxy_set_header        X-Real-IP $remote_addr;   proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;   proxy_pass http://localhost:8080/index;}</code></pre><p>外面访问：<a href="http://romotehost/index/index.html" target="_blank" rel="noopener">http://romotehost/index/index.html</a><br>相当于访问：<a href="http://localhost:8080/index/index.html" target="_blank" rel="noopener">http://localhost:8080/index/index.html</a></p><h4 id="二-location匹配路径末尾有"><a href="#二-location匹配路径末尾有" class="headerlink" title="二. location匹配路径末尾有 /"></a>二. location匹配路径末尾有 /</h4><p>此时proxy_pass后面的路径需要分为以下四种情况讨论：</p><ul><li>proxy_pass后面的路径只有域名且最后没有 /：<pre><code>location /index/{ proxy_redirect off; proxy_set_header        Host $host; proxy_set_header        X-Real-IP $remote_addr; proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://localhost:8080;}</code></pre></li></ul><p>外面访问：<a href="http://romotehost/index/index.html" target="_blank" rel="noopener">http://romotehost/index/index.html</a><br>相当于访问：<a href="http://localhost:8080/index/index.html" target="_blank" rel="noopener">http://localhost:8080/index/index.html</a></p><ul><li><p>proxy_pass后面的路径只有域名同时最后有 /：</p><pre><code>location /index/{ proxy_redirect off; proxy_set_header        Host $host; proxy_set_header        X-Real-IP $remote_addr; proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://localhost:8080/;}</code></pre><p>外面访问：<a href="http://romotehost/index/index.html" target="_blank" rel="noopener">http://romotehost/index/index.html</a><br>相当于访问：<a href="http://localhost:8080/index.html" target="_blank" rel="noopener">http://localhost:8080/index.html</a></p></li><li><p>proxy_pass后面的路径还有其他路径但是最后没有 /：</p><pre><code>location /index/{ proxy_redirect off; proxy_set_header        Host $host; proxy_set_header        X-Real-IP $remote_addr; proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://localhost:8080/test;}</code></pre></li></ul><p>外面访问：<a href="http://romotehost/index/index.html" target="_blank" rel="noopener">http://romotehost/index/index.html</a><br>相当于访问：<a href="http://localhost:8080/testindex.html" target="_blank" rel="noopener">http://localhost:8080/testindex.html</a></p><ul><li>proxy_pass后面的路径还有其他路径同时最后有 /：<pre><code>location /index/{ proxy_redirect off; proxy_set_header        Host $host; proxy_set_header        X-Real-IP $remote_addr; proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://localhost:8080/test/;}</code></pre></li></ul><p>外面访问：<a href="http://romotehost/index/index.html" target="_blank" rel="noopener">http://romotehost/index/index.html</a><br>相当于访问：<a href="http://localhost:8080/index/index.html" target="_blank" rel="noopener">http://localhost:8080/index/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非root用户安装ngnix</title>
      <link href="/2019/04/18/linux/install-ngnix-without-root/"/>
      <url>/2019/04/18/linux/install-ngnix-without-root/</url>
      
        <content type="html"><![CDATA[<p>如果在开发机上没有root权限，怎么搭建自己的nginx服务。</p><a id="more"></a><h4 id="非root用户从源码编译安装nginx"><a href="#非root用户从源码编译安装nginx" class="headerlink" title="非root用户从源码编译安装nginx"></a>非root用户从源码编译安装nginx</h4><ul><li>获取依赖库nginx依赖pcre和zlib两个库,openssl库非必须，但一般都加上，https支持需要<pre><code>wget https://sourceforge.net/projects/libpng/files/zlib/1.2.11/zlib-1.2.11.tar.gztar zxvf zlib-1.2.11.tar.gzwget https://sourceforge.net/projects/pcre/files/pcre/8.43/pcre-8.43.tar.gztar zxvf pcre-8.43.tar.gzwget https://www.openssl.org/source/openssl-1.0.2r.tar.gztar zxvf openssl-1.0.2r.tar.gz</code></pre></li></ul><p>pcre源码在<a href="https://sourceforge.net/projects/pcre/files/pcre/" target="_blank" rel="noopener">https://sourceforge.net/projects/pcre/files/pcre/</a>可自行选择版本  </p><p>zlib源码在<a href="https://sourceforge.net/projects/libpng/files/zlib/" target="_blank" rel="noopener">https://sourceforge.net/projects/libpng/files/zlib/</a>,可自行选择版本  </p><p>openssl源码在<a href="https://www.openssl.org/source/" target="_blank" rel="noopener">https://www.openssl.org/source/</a>,可自行选择版本  </p><p>解压后无需安装自己编译的话nginx是通过源码依赖这些库的。</p><ul><li><p>获取nginx源码</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">wget</span> https://nginx.org/download/nginx-1.14.2.tar.gz<span class="token function">tar</span> zxvf nginx-1.14.2.tar.gz<span class="token function">cd</span> nginx-1.14.2<span class="token comment" spellcheck="true"># 指定安装路径和pcre、zlib源代码位置,pcre和zlib的路径都是上面解压的源码路径</span>./configure --prefix<span class="token operator">=</span>/path/to/nginx --with-pcre<span class="token operator">=</span>/path/to/pcre --with-zlib<span class="token operator">=</span>/path/to/zlib --with-openssl<span class="token operator">=</span>/path/to/openssl<span class="token function">make</span><span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>nginx源码在<a href="https://nginx.org/en/download.html" target="_blank" rel="noopener">https://nginx.org/en/download.html</a>,可自己选择版本。</p></li><li><p>修改环境变量</p><pre><code>export PATH=$PATH:/path/to/nginx/sbin</code></pre></li><li><p>修改端口，将由于非root，所有无法绑定1024以下的端口，在<code>ngnix.conf</code>将nginx绑定的端口改成大于1024的，比如8080。启动ngnix  <code>nohup ngnix &gt;&gt; nginx.log &amp;</code>。 这是访问<a href="http://host:8080就可以看到nginx主页了。">http://host:8080就可以看到nginx主页了。</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu安装升级cmake</title>
      <link href="/2019/04/16/linux/ubuntu-upgrade-cmake/"/>
      <url>/2019/04/16/linux/ubuntu-upgrade-cmake/</url>
      
        <content type="html"><![CDATA[<p>cmake 安装升级避坑指南。</p><a id="more"></a><h4 id="1-通过ppa安装"><a href="#1-通过ppa安装" class="headerlink" title="1.通过ppa安装"></a>1.通过ppa安装</h4><ul><li>apt repository 加入ppa<pre><code>sudo apt-get install software-properties-commonsudo add-apt-repository ppa:george-edison55/cmake-3.xsudo apt-get update</code></pre></li><li>如果系统默认自带了老版本的cmake，先卸载<pre><code>sudo apt-get remove cmake</code></pre></li><li>安装cmake<pre><code>sudo apt-get install cmake</code></pre></li></ul><h4 id="2-从源码编译安装（可以非root用户安装）"><a href="#2-从源码编译安装（可以非root用户安装）" class="headerlink" title="2.从源码编译安装（可以非root用户安装）"></a>2.从源码编译安装（可以非root用户安装）</h4><ul><li><p>获取源码编译</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 源码可以从[https://cmake.org/files/](https://cmake.org/files/)获得，选择你希望安装的版本，以3.7为例</span><span class="token function">wget</span> https://cmake.org/files/v3.7/cmake-3.7.0.tar.gz<span class="token function">tar</span> xf cmake-3.7.0.tar.gz<span class="token function">cd</span> cmake-3.7.0<span class="token comment" spellcheck="true"># 如果没有root权限， ./configure --prefix=/user/home/dev   --prefix 设置用户有写入权限的安装路径</span>./configure<span class="token function">make</span><span class="token comment" spellcheck="true"># 如果缺少一些编译依赖，执行</span><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> build-essential<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果系统默认自带了老版本的cmake，先卸载</p><pre><code>sudo apt-get remove cmake</code></pre></li><li><p>安装</p><ul><li><code>checkinstall</code>方式安装，<code>checkinstall</code>的方式安装会生成deb包，比较便于管理，后续卸载也方便，比较推荐。<pre><code> sudo apt-get install checkinstall sudo checkinstall  # 非root不用sudo</code></pre></li><li><code>make install</code> 方式安装，如果非root，不用sudo。<pre><code>make install</code></pre></li></ul></li></ul><p><strong>备注:</strong> 如果系统自带着低版本的cmake需要升级，比较靠谱的办法还是先卸载了，再重装，<code>sudo apt-get upgrade</code>的方法不一定能成功。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu命令行查看网络流量</title>
      <link href="/2019/04/15/linux/ubuntu-net-stats-in-termial/"/>
      <url>/2019/04/15/linux/ubuntu-net-stats-in-termial/</url>
      
        <content type="html"><![CDATA[<p>命令行查看网络流量的几个小工具。</p><a id="more"></a><h4 id="1-nethogs"><a href="#1-nethogs" class="headerlink" title="1.nethogs"></a>1.nethogs</h4><p>nethogs可以查看实时进程网络占用。<br>安装： <code>sudo apt install nethogs</code><br>查看网络状态： <code>nethogs 网卡</code>，如 <code>nethogs eth0</code><br>网卡可以使用 <code>ifconfig</code> 查看</p><p><img src="http://img.kingway.fun/IMGMatrix/blog/linux/net002.png" alt=""></p><h4 id="2-bmon"><a href="#2-bmon" class="headerlink" title="2.bmon"></a>2.bmon</h4><p>安装 <code>sudo apt-get install bmon</code><br>查看所有网卡 <code>bmon</code><br>查看特定网卡 <code>bmon -p eth0</code><br>网卡可以使用 <code>ifconfig</code> 查看  </p><ul><li>使用上下按键选择要显示的网卡</li><li>输入g控制流量面板的显示和隐藏 </li><li>输入d控制详情信息的显示和隐藏 </li><li>输入q退出面板 </li></ul><p><img src="http://img.kingway.fun/IMGMatrix/blog/linux/net001.jpeg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows上使用git仓库的问题</title>
      <link href="/2019/03/17/linux/issues-using-git-in-windows/"/>
      <url>/2019/03/17/linux/issues-using-git-in-windows/</url>
      
        <content type="html"><![CDATA[<p>团队开发过程中经常会使用git工具来管理代码，团队中成员使用的终端可能是windows和类Unix系统，由于操作系统的差异可能会给大家使用git带来一些困扰。尤其是将类Unix系统中建立的仓库在windows系统打开的时候。在windows上使用<code>*nix</code>建立的仓库主要处理好三个事情，换行符、文件权限、软连接。</p><a id="more"></a><h4 id="1-处理换行符"><a href="#1-处理换行符" class="headerlink" title="1.处理换行符"></a>1.处理换行符</h4><p>&#160; &#160; &#160; &#160;换行符在各个系统中有不同的表示，一般使用两种符号，一种是<code>LF\n</code>换行,一种是<code>CR\r</code>回车。windows系统使用的是<code>\r\n</code>, unix系统使用的是<code>\r</code>,linux系统使用的是<code>\n</code>。这样就导致从不同系统checkout代码时出现文件未修改却出现modified的情况，git对此有自动转换的机制，设置<code>core.autocrlf</code>为<code>true</code>,在checkout和checkin时就会自动转换换行符。</p><pre><code>git config --global core.autocrlf true</code></pre><h4 id="2-处理权限"><a href="#2-处理权限" class="headerlink" title="2.处理权限"></a>2.处理权限</h4><p>*nix系统对拥有者、组、其他几种用户都有明确的读写执行权限，这些在windows上没有对应的机制，这个问题在使用git时表现为没有修改文件却出现很多modified的文件，<code>git status</code>显示 typechange。一般出现在增加可执行权限的文件上。git对此也有一定的策略，可以设置<code>core.filemode</code>为<code>false</code>,这样就会忽略文件权限带来的改变。</p><pre><code>git config --add core.filemode false</code></pre><p>如果clone前没有设置，导致已经进行了修改，可以用下面的命令来批量恢复这些修改。</p><pre><code>git status | grep typechange | awk &#39;{print $2}&#39; | xargs git checkout</code></pre><h4 id="3-处理软链接"><a href="#3-处理软链接" class="headerlink" title="3.处理软链接"></a>3.处理软链接</h4><p>这可能是最让人头疼的问题，在*nix系统里我们经常会使用<code>ln</code>来给文件和文件夹设置软链接，而这些软链接到windwos就失效了，不能进行导航，ide也不识别，如果有关键文件夹设置了软链接，仓库在windows上就基本不可用了。这也是笔者遇到的一大难题。  </p><p>git暂时还不能像处理换行符一样优雅的处理软链接，需要我们自己手动来处理。windows中也有自己的软链接实现方式，建立软链接使用<code>mklink</code>命令，<code>mklink</code>的使用文档是这么写的：</p><blockquote><p>MKLINK [[/D] | [/H] | [/J]] Link Target  </p></blockquote><blockquote><p>/D creates a symbolic link, or a soft link.This essentially acts like a shortcut to a folder in prior versions of Windows, except you don’t have to use an actual shortcut.  </p></blockquote><blockquote><p>/H creates a hard link, which points directly to the file.This option can’t be used for folders directly for some reason, you’ll have to use the next option.  </p></blockquote><blockquote><p>/J creates a “Directory Junction”A Directory Junction is actually just a hard link to a directory. This is a feature that existed prior to Vista as well. If you are trying to symlink to a directory using a hard link, then you should use this option.</p></blockquote><p>主要就分为三种，<code>/D</code> <code>/J</code> <code>/H</code>,<code>/D</code>和<code>/J</code>用于目录，<code>/H</code>用于文件，对链接的修改对不会影响源文件，<code>/D</code>和<code>/J</code>不会占用空间，<code>/H</code>会占用空间。具体可以参考<a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/mklink" target="_blank" rel="noopener">mklink</a>. </p><p>现在我们就要将*nix中的所有软链接换成windows的link，主要三步：</p><ul><li>找到软链接文件<ul><li>使用<code>git ls-files -s</code>,git把所有的软链接设置成<code>120000</code>类型</li></ul></li><li>修改软链接<ul><li>使用<code>mklink</code>命令</li></ul></li><li>屏蔽软链接的修改<ul><li>使用<code>git update-index --assume-unchanged</code>  </li></ul></li></ul><p>上述步骤已经整理成一个python脚本，可以从我的<a href="https://gist.github.com/pkufool/b9ad6830e60058070f84eb1762ad5a14" target="_blank" rel="noopener">gist</a>获得。脚本只在<a href="https://babun.github.io/" target="_blank" rel="noopener">Babun-windows上最好用的终端</a> 测试过，其他终端可能无法使用，如有错误请自行修改。</p><p>考虑国内访问github速度，贴出脚本如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">def</span> <span class="token function">rindex</span><span class="token punctuation">(</span>lst<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> lst<span class="token punctuation">.</span>rindex<span class="token punctuation">(</span>value<span class="token punctuation">)</span>  <span class="token keyword">except</span> ValueError<span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token comment" spellcheck="true"># find symbol link files or dirs</span>fp <span class="token operator">=</span> os<span class="token punctuation">.</span>popen<span class="token punctuation">(</span><span class="token string">"git ls-files -s | awk '/120000/{print $4}'"</span><span class="token punctuation">)</span>links <span class="token operator">=</span> fp<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># get symbol links' parent dir</span>link_dir <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> link <span class="token keyword">in</span> links<span class="token punctuation">:</span>    index <span class="token operator">=</span> rindex<span class="token punctuation">(</span>link<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      link_dir<span class="token punctuation">.</span>add<span class="token punctuation">(</span>link<span class="token punctuation">[</span><span class="token punctuation">:</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>      link_dir<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>work_dir <span class="token operator">=</span> os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># make link for every symbol link</span><span class="token keyword">for</span> d <span class="token keyword">in</span> link_dir<span class="token punctuation">:</span>  os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>work_dir<span class="token punctuation">,</span>d<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  fp <span class="token operator">=</span> os<span class="token punctuation">.</span>popen<span class="token punctuation">(</span><span class="token string">"ls -la"</span><span class="token punctuation">)</span>  items <span class="token operator">=</span> fp<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span>  <span class="token keyword">for</span> item <span class="token keyword">in</span> items<span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token string">"->"</span> <span class="token keyword">in</span> item<span class="token punctuation">:</span>      tks <span class="token operator">=</span> item<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"->"</span><span class="token punctuation">)</span>      src <span class="token operator">=</span> tks<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>      dst <span class="token operator">=</span> tks<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>dst<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        dst <span class="token operator">=</span> <span class="token string">"\\\\"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>dst<span class="token punctuation">)</span>      <span class="token keyword">else</span><span class="token punctuation">:</span>        dst <span class="token operator">=</span> dst<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>      <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"link "</span> <span class="token operator">+</span> src <span class="token operator">+</span> <span class="token string">" -> "</span> <span class="token operator">+</span> dst<span class="token punctuation">)</span>      os<span class="token punctuation">.</span>popen<span class="token punctuation">(</span><span class="token string">"rm "</span> <span class="token operator">+</span> src<span class="token punctuation">)</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isfile<span class="token punctuation">(</span>dst<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        os<span class="token punctuation">.</span>popen<span class="token punctuation">(</span><span class="token string">"cmd /c mklink /H "</span> <span class="token operator">+</span> src <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> dst<span class="token punctuation">)</span>      <span class="token keyword">else</span><span class="token punctuation">:</span>        os<span class="token punctuation">.</span>popen<span class="token punctuation">(</span><span class="token string">"cmd /c mklink /j "</span> <span class="token operator">+</span> src <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> dst<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># make links unchanged </span>      os<span class="token punctuation">.</span>popen<span class="token punctuation">(</span><span class="token string">"git update-index --assume-unchanged "</span> <span class="token operator">+</span> <span class="token string">"/"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> src<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一分钟学git stash</title>
      <link href="/2019/03/10/linux/git-stash-in-one-minute/"/>
      <url>/2019/03/10/linux/git-stash-in-one-minute/</url>
      
        <content type="html"><![CDATA[<p>在使用git管理代码时会经常使用到<code>git stash</code>这个命令，一分钟复习一下。<br>一般什么情况下会用stash呢？当前修改还没完成，或者暂时不想<code>commit</code>，然而需要做<code>pull</code>，<code>merge</code>或者<code>checkout</code>到其他分支的操作，一般会用stash将修改暂时储藏。<br>接下来我们复习一些<code>stash</code>的三板斧，增、删、恢复。</p><a id="more"></a><ul><li><p>增加储藏<br>任何时候想要<code>stash</code>当前的修改，只需要用<code>git stash</code>命令，git会按栈的方式按先后顺序记录。</p><pre><code>git stash# save -a 增加助记messagegit stash save -a &quot;message&quot;</code></pre></li><li><p>查看储藏<br>查看储藏使用<code>git stash list</code>命令，所有储藏按先后顺序出现，<code>stash@{0}</code>表示最近一次储藏。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> stash liststash@<span class="token punctuation">{</span>0<span class="token punctuation">}</span>: WIP on master: 049d078 added the index <span class="token function">file</span>stash@<span class="token punctuation">{</span>1<span class="token punctuation">}</span>: WIP on master: c264051 Revert <span class="token string">"added file_size"</span>stash@<span class="token punctuation">{</span>2<span class="token punctuation">}</span>: WIP on master: 21d80a5 added number to log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>应用储藏<br>将储藏重新应用有两种方式，<code>git stash pop</code>和<code>git stash apply</code>，pop应用后会将储藏删除，而apply不会删除。另外，<strong>stash操作是不随分支的，无论在哪个分支的stash，都可以应用到任何分支</strong>。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 默认apply最近的一次stash</span><span class="token function">git</span> stash apply <span class="token comment" spellcheck="true"># apply 以前的stash</span><span class="token function">git</span> stash apply stash@<span class="token punctuation">{</span>2<span class="token punctuation">}</span>默认pop最近的一次stash<span class="token function">git</span> stash pop <span class="token comment" spellcheck="true"># pop以前的stash</span><span class="token function">git</span> stash pop stash@<span class="token punctuation">{</span>2<span class="token punctuation">}</span><span class="token comment" spellcheck="true"># pop 之后会删除</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>撤回储藏<br>有时候应用储藏后，会有撤回的需求，比如你正在修改文件，然后apply了一个储存，之后又不想要储存里apply的修改了，可以运用撤回来清除这个储藏。</p><pre><code>git stash show -p stash@{0} | git apply -R# 如果没有指定则会撤回最近的储藏git stash show -p | git apply -R</code></pre></li><li><p>删除储藏<br>用apply应用的储藏是不会删除的，需要手工删除，可以通过drop来做，可以指定stash，也可以clear全部删除（慎用）</p><pre><code>git stash drop stash@{0}# 全部删除git stash drop clear</code></pre></li><li><p>从储藏创建分支<br>有时候一些修改希望单独出一个分支来继续改进，那么可以将这个stash直接checkout成一个单独的分支。</p><pre><code>git stash branch testchanges</code></pre><p>OK，<code>git stash</code>就这三板斧，记起来了吗？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
